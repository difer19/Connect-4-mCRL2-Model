sort Token = struct O|X|null;
	 Position = List(List(Token));

map Rows: Nat;
	Columns: Nat;
	initPosition: Position;
	next: Token->Token;
	isWinner: Position#Token->Bool;

 	replaceBoard: Position#Nat#Nat#Token->Position;
 	replaceColumn: List(Token)#Nat#Token->List(Token);

	getCol: Position#Nat -> List(Token);
	getRowValue: List(Token) -> Nat;

	maxDepth: Nat;

var m: Token;
	b: Position;
	llst: Position;
 	i, j: Nat;
 	e, n: Token;
	ls: List(Token);
	columnIndex: Nat;

eqn 
	Rows = 6;
	Columns = 7;
	initPosition = [
		[null,null,null,null,null,null,null],
		[null,null,null,null,null,null,null],
		[null,null,null,null,null,null,null],
		[null,null,null,null,null,null,null],
		[null,null,null,null,null,null,null],
		[null,null,null,null,null,null,null]
	];
	
	
	
	next(X) = O;
	next(O) = X;
	
	isWinner(b,m) =
 		(exists row: Nat.(row<Rows && 
							((b.row.0==m && b.row.1==m && b.row.2==m && b.row.3==m) ||
							(b.row.1==m && b.row.2==m && b.row.3==m && b.row.4==m) ||
							(b.row.2==m && b.row.3==m && b.row.4==m && b.row.5==m) ||
							(b.row.3==m && b.row.4==m && b.row.5==m && b.row.6==m) ))) ||
											
 		(exists col: Nat.(col<Columns && 
							((b.0.col==m && b.1.col==m && b.2.col==m && b.3.col==m) ||
							(b.1.col==m && b.2.col==m && b.3.col==m && b.4.col==m) ||
							(b.2.col==m && b.3.col==m && b.4.col==m && b.5.col==m) ))) ||
 		
		(b.0.0  == m && b.1.1  == m && b.2.2  == m && b.3.3  == m ) ||
		(b.0.1  == m && b.1.2  == m && b.2.3  == m && b.3.4  == m ) ||
		(b.0.2  == m && b.1.3  == m && b.2.4  == m && b.3.5  == m ) ||
		(b.0.3  == m && b.1.4  == m && b.2.5  == m && b.3.6  == m ) ||
		(b.1.0  == m && b.2.1  == m && b.3.2  == m && b.4.3  == m ) ||
		(b.1.1  == m && b.2.2  == m && b.3.3  == m && b.4.4  == m ) ||
		(b.1.2  == m && b.2.3  == m && b.3.4  == m && b.4.5  == m ) ||
		(b.1.3  == m && b.2.4  == m && b.3.5  == m && b.4.6  == m ) ||
		(b.2.0  == m && b.3.1  == m && b.4.2  == m && b.5.3  == m ) ||
		(b.2.1  == m && b.3.2  == m && b.4.3  == m && b.5.4  == m ) ||
		(b.2.2  == m && b.3.3  == m && b.4.4  == m && b.5.5  == m ) ||
		(b.2.3  == m && b.3.4  == m && b.4.5  == m && b.5.6  == m ) ||
		(b.0.3  == m && b.1.2  == m && b.2.1  == m && b.3.0  == m ) ||
		(b.0.4  == m && b.1.3  == m && b.2.2  == m && b.3.1  == m ) ||
		(b.0.5  == m && b.1.4  == m && b.2.3  == m && b.3.2  == m ) ||
		(b.0.6  == m && b.1.5  == m && b.2.4  == m && b.3.3  == m ) ||
		(b.1.3  == m && b.2.2  == m && b.3.1  == m && b.4.0  == m ) ||
		(b.1.4  == m && b.2.3  == m && b.3.2  == m && b.4.1  == m ) ||
		(b.1.5  == m && b.2.4  == m && b.3.3  == m && b.4.2  == m ) ||
		(b.1.6  == m && b.2.5  == m && b.3.4  == m && b.4.3  == m ) ||
		(b.2.3  == m && b.3.2  == m && b.4.1  == m && b.5.0  == m ) ||
		(b.2.4  == m && b.3.3  == m && b.4.2  == m && b.5.1  == m ) ||
		(b.2.5  == m && b.3.4  == m && b.4.3  == m && b.5.2  == m ) ||
		(b.2.6  == m && b.3.5  == m && b.4.4  == m && b.5.3  == m ) ;


 	replaceBoard ([], i, j, n)=[];

 	replaceBoard(ls|>llst,i,j,n)=if(i==0,replaceColumn(ls,j,n)|>llst,
 			ls|>replaceBoard(llst, Int2Nat(i-1), j, n));

	replaceColumn([], j, n) = [];

 	replaceColumn(e|>ls,j,n) = if(j==0,n|>ls,
		 e|>replaceColumn(ls, Int2Nat(j-1), n));

	getCol(b, columnIndex) =
    	if(columnIndex < Columns, 
		[b.0.columnIndex, b.1.columnIndex, b.2.columnIndex, b.3.columnIndex, b.4.columnIndex, b.5.columnIndex], 
	[]);


	getRowValue([]) = 8;
	getRowValue(ls) = if(rhead(ls)==null, #ls, getRowValue(rtail(ls)));

	maxDepth = 2;

act place: Nat#Nat#Token;
 	win: Token;
	pos : Position;
	pso : Position#Nat;
	backtracking, defSuccessor;
	max, min;

proc GenSuccesors(b: Position, m: Token, depth: Nat) =
	sum c:Nat.(c < Columns && null in getCol(b,c)) ->
		pos(replaceBoard(b, Int2Nat((getRowValue(getCol(b,c)))-1),c,m)).
		Game(replaceBoard(b, Int2Nat((getRowValue(getCol(b,c)))-1),c,m), next(m), Int2Nat(depth+1));

proc GenSuccessoMinmax(b: Position, m: Token, depth: Nat, thread: Nat) =
	sum c:Nat.(c < Columns && null in getCol(b,c)) ->
		%pso(replaceBoard(b, Int2Nat((getRowValue(getCol(b,c)))-1),c,m), thread).
		%max.Minmax(replaceBoard(b, Int2Nat((getRowValue(getCol(b,c)))-1),c,m), next(m), Int2Nat(depth+1), thread)
		(m == O) -> max.Minmax(replaceBoard(b, Int2Nat((getRowValue(getCol(b,c)))-1),c,m), next(m), Int2Nat(depth+1), thread)
		<> min.Minmax(replaceBoard(b, Int2Nat((getRowValue(getCol(b,c)))-1),c,m), next(m), Int2Nat(depth+1), thread);

proc processPool(b: Position, m: Token, depth: Nat, c: Nat, thread: Nat) =
	(null in getCol(b,c)) -> 
		Minmax(replaceBoard(b, Int2Nat((getRowValue(getCol(b,c)))-1),c,m), next(m), Int2Nat(depth+1), thread);

proc Game(b: Position, m: Token, depth: Nat) = 
	(isWinner(b,next(m))) ->
			win(next(m)).delta
	<> (depth < maxDepth) -> 
			GenSuccesors(b, m, depth)
	<> delta;

proc Minmax(b: Position, m: Token, depth: Nat, thread: Nat) = 
	(isWinner(b,next(m))) ->
		backtracking.defSuccessor.delta
	<> (depth <= maxDepth) -> 
			GenSuccessoMinmax(b, m, depth, thread)
	<> backtracking.defSuccessor.delta;


% init Game(initPosition, X, 0);
init allow ({max, min, backtracking|backtracking, defSuccessor|defSuccessor}, 
	processPool(initPosition, X, 0, 0, 1) || processPool(initPosition, X, 0, 1, 2));
%init processPool(initPosition, X, 0, 0, 1);



